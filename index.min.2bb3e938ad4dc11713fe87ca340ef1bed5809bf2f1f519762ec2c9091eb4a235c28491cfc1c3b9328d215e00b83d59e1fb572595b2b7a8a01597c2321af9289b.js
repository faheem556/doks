var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/blog/kubernetes-authentication/",title:"Kubernetes Authentication",description:"",content:'\u003cp\u003eIn this post, we will discuss two types of accounts that access the Kubernetes cluster. Users and machines.  Authentication in Kubernetes is about verifying the identity of users and services. Administrators manage the cluster. Developers deploy applications to the cluster. End-users use applications deployed on the cluster. They authenticate with the application running on the cluster. They do not need access to the cluster. Cluster administrators and application developers do need access to the clusters. Machines, processes, or applications also need access to the cluster. They use service accounts to access the cluster.\u003c/p\u003e\n\u003cfigure class="wide"\u003e\n  \u003cimg class="img-fluid lazyload blur-up" data-sizes="auto" src="/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_20x0_resize_box_2.png" data-srcset="https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_900x0_resize_box_2.png 900w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_800x0_resize_box_2.png 800w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_700x0_resize_box_2.png 700w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_600x0_resize_box_2.png 600w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_500x0_resize_box_2.png 500w" width="1280" height="720" alt="Kubernetes Authentication"\u003e\n  \u003cnoscript\u003e\u003cimg class="img-fluid" sizes="100vw" srcset="https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_900x0_resize_box_2.png 900w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_800x0_resize_box_2.png 800w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_700x0_resize_box_2.png 700w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_600x0_resize_box_2.png 600w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_500x0_resize_box_2.png 500w" src="/blog/kubernetes-authentication/kubernetes-authentication.png" width="1280" height="720" alt="Kubernetes Authentication"\u003e\u003c/noscript\u003e\n  \u003cfigcaption class="figure-caption"\u003eKubernetes Authentication\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003ch3 id="how-do-users-connect-to-the-cluster"\u003eHow do users connect to the cluster?\u003c/h3\u003e\n\u003cp\u003eKubernetes does not have objects which represent user accounts. Users do not log in, and there are no sessions or timeouts. Every request made to the API server is unique. It contains everything that the API server requires to authenticate/authorize the request.  You can choose many authentication mechanisms that are suitable for your implementation.\u003c/p\u003e\n\u003cp\u003eOne of the simplest methods is to use a Static Token file. The API server reads bearer tokens from this file that you specify as a command-line option. It is not a recommended method as the tokens can last forever. You need to access the node running the API server to update the file. Every time you make changes to the file, you have to restart the API server. The token file is a csv file with three columns: token, user name, user uid, and optional group names.\u003c/p\u003e\n\u003cp\u003eUsers can authenticate by presenting a certificate signed by the cluster\u0026rsquo;s certificate authority (CA). The user submits the certificate in the form of a Certificate Header or through the kubectl command. The API server reads the username (CN=devuser) and group name (O=engineering) from the ‘subject’ line of the certificate. When using this method, the administrators are responsible for generating, revoking, and expiry of certificates.\u003c/p\u003e\n\u003cp\u003eMost of the time, you would be using OIDC (OpenID Connect) in a production or cloud environment. Users authenticate with their OIDC platform to get tokens. The administrators configure the API server to accept these tokens that contain identity information. An important concept to understand is that you do not connect Kubernetes to a user directory.\u003c/p\u003e\n\u003cp\u003eTwo more methods are available if you need to use custom identity providers. Using an authenticating proxy or authentication webhook, you can integrate with LDAP, SAML, Kerberos, alternate x509 schemes, etc.). You use HTTP headers to specify a username, group, and any extra information about the user. On the API server, you map these headers to the required API server switches.\u003c/p\u003e\n\u003cp\u003eWebhook authentication allows your users to generate tokens through the external service. The users use these tokens when authenticating with the API server. When a client starts to authenticate using a bearer token, the authentication webhook POSTs a JSON-serialized TokenReview object containing the token to the remote service. The remote service indicates success by updating a status field in the request.  Usernames derived from various supported authentication identity providers must be unique cluster-wide.\u003c/p\u003e\n\u003ch3 id="how-do-things-running-inside-the-cluster-interact-with-each-other"\u003eHow do things running inside the cluster interact with each other?\u003c/h3\u003e\n\u003cp\u003eThe Service Account controller manages service accounts inside namespaces. It creates a service account named “default” in all active namespaces. When you create a pod without a service account, it will use the “default” service account in the namespace. Service accounts that do not belong to the kube-system namespace have no permissions. Application access the API server using the service account specified in their pod. An excellent example of such an application is a Kubernetes dashboard that exists in a pod. It will use the service account to talk to the API server. Service accounts use credentials from secrets mounted into pods. You can only use one service account per pod. You can specify a service account in the pods manifest. You can grant particular roles to service accounts as needed. You should create application-specific service accounts and then give them permissions as required.\u003c/p\u003e\n\u003cp\u003eWhen the API server creates a service account, it generates a token and stores it in a Secret object. The API server then links this to the newly created service account. The token in secret is an authentication bearer token used to communicate with the API server. When you create pods, this secret is made available to the pod as a volume.\u003c/p\u003e\n\u003ch3 id="key-takeaways"\u003eKey Takeaways\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAuthentication in Kubernetes is about verifying the identity of users (humans) and services (machines, processes, or applications).\u003c/li\u003e\n\u003cli\u003eKubernetes does not have objects which represent user accounts. Users do not log in, and there are no sessions or timeouts.\u003c/li\u003e\n\u003cli\u003eYou do not connect Kubernetes to a user directory.\nKubernetes supports several authentication mechanisms out of the box and provides support for custom authentication schemes.\u003c/li\u003e\n\u003cli\u003eUsernames derived from various supported authentication identity providers must be unique cluster-wide.\u003c/li\u003e\n\u003cli\u003eA service account named “default” exists in all active namespaces.\u003c/li\u003e\n\u003cli\u003eService accounts that do not belong to the kube-system namespace have no permissions.\u003c/li\u003e\n\u003cli\u003eService accounts use credentials from secrets mounted into pods. Each pod can use one service account only.\u003c/li\u003e\n\u003cli\u003eWhen you create pods, the secret in the service account is made available as a volume.\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:1,href:"/blog/",title:"Blog",description:"The foreops blog.",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()