var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/blog/kubernetes-authentication/",title:"Kubernetes Authentication",description:"Authentication in Kubernetes is about verifying the identity of users and services.",content:'\u003cp\u003eAuthentication in Kubernetes is about verifying the identity of users and services. This post will discuss authentication methods for two types of accounts that access the Kubernetes cluster: users and machines. While cluster administrators and application developers require access to the cluster to manage and deploy applications respectively, machines, processes, and applications also need access to the cluster, which they obtain through the service accounts.\u003c/p\u003e\n\u003cfigure class="wide"\u003e\n  \u003cimg class="img-fluid lazyload blur-up" data-sizes="auto" src="/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_20x0_resize_box_2.png" data-srcset="https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_900x0_resize_box_2.png 900w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_800x0_resize_box_2.png 800w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_700x0_resize_box_2.png 700w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_600x0_resize_box_2.png 600w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_500x0_resize_box_2.png 500w" width="1280" height="720" alt="Kubernetes Authentication"\u003e\n  \u003cnoscript\u003e\u003cimg class="img-fluid" sizes="100vw" srcset="https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_900x0_resize_box_2.png 900w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_800x0_resize_box_2.png 800w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_700x0_resize_box_2.png 700w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_600x0_resize_box_2.png 600w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_500x0_resize_box_2.png 500w" src="/blog/kubernetes-authentication/kubernetes-authentication.png" width="1280" height="720" alt="Kubernetes Authentication"\u003e\u003c/noscript\u003e\n  \u003cfigcaption class="figure-caption"\u003eKubernetes Authentication\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003ch3 id="user-authentication"\u003eUser Authentication\u003c/h3\u003e\n\u003cp\u003eKubernetes does not have objects which represent user accounts. Users do not log in, and there are no sessions or timeouts. Every request made to the API server is unique, and it contains everything that the API server requires to authenticate/authorize the request. There are many different authentication mechanisms to choose from based on suitability to specific types of implementation.\u003c/p\u003e\n\u003cp\u003eOne of the simplest methods is to use a static token file in CSV format with three required columns: token, user name, user uid, and an optional column for group names. The API server reads bearer tokens from this file which is specified as a command-line option. Updates to the file require access to the node running the API server. Every time the file changes, you have to restart the API server. However, this is not a recommended authentication method as the tokens can last forever.\u003c/p\u003e\n\u003cp\u003eUsers can also authenticate by presenting a certificate signed by the cluster\u0026rsquo;s certificate authority (CA). The user submits the certificate in the form of a Certificate Header or through the kubectl command. The API server reads the username (CN=devuser) and group name (O=engineering) from the \u0026lsquo;subject\u0026rsquo; line of the certificate. When using this method, the administrators are responsible for generating, revoking, and expiry of certificates.\u003c/p\u003e\n\u003cp\u003eMost of the time, OIDC (OpenID Connect) is used in a production or cloud environment. Users authenticate with their OIDC platform to get tokens. The administrators configure the API server to accept these tokens that contain identity information. It Is also important to note that Kubernetes does not connect to a user directory.\u003c/p\u003e\n\u003cp\u003eTwo more methods are available to use custom identity providers, authenticating proxy or authentication webhook. Authentication proxy used to integrate with LDAP, SAML, Kerberos, alternate x509 schemes, etc. HTTP headers specify a username, group, and any extra information about the user. On the API server, these headers are mapped to the required API server switches.\u003c/p\u003e\n\u003cp\u003eWebhook authentication allows users to generate tokens through the external service. The users use these tokens when authenticating with the API server. When a client starts to authenticate using a bearer token, the authentication webhook POSTs a JSON-serialized TokenReview object containing the token to the remote service. The remote service indicates success by updating a status field in the request. Usernames derived from various supported authentication identity providers must be unique cluster-wide.\u003c/p\u003e\n\u003ch3 id="machine-authentication"\u003eMachine Authentication\u003c/h3\u003e\n\u003cp\u003eThe Service Account controller manages service accounts inside namespaces. It creates a service account named \u0026ldquo;default\u0026rdquo; in all active namespaces. When a pod\u0026rsquo;s manifest does not specify a service account,  it will use the \u0026ldquo;default\u0026rdquo; service account in its namespace. Service accounts that do not belong to the kube-system namespace have no permissions. Applications access the API server using the service account specified in their pod. An excellent example of such an application is a Kubernetes dashboard that exists in a pod. It will use the service account to talk to the API server. Service accounts use credentials from secrets mounted into pods. Only one service account is per pod is used. Any required roles can be granted to service accounts as needed. Application-specific service accounts should be created and given permissions as needed.\u003c/p\u003e\n\u003cp\u003eWhen the API server creates a service account, it generates a token and stores it in a secret object. The API server then links this to the newly created service account. The token in secret is an authentication bearer token used to communicate with the API server. On pods creation, the secret is made available to the pod as a volume.\u003c/p\u003e\n\u003ch3 id="key-takeaways"\u003eKey Takeaways\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAuthentication in Kubernetes is about verifying the identity of users (humans) and services (machines, processes, or applications).\nKubernetes does not have objects which represent user accounts. Users do not log in, and there are no sessions or timeouts.\u003c/li\u003e\n\u003cli\u003eYou do not connect Kubernetes to a user directory. Kubernetes supports several authentication mechanisms out of the box and provides support for custom authentication schemes.\u003c/li\u003e\n\u003cli\u003eUsernames derived from various supported authentication identity providers must be unique cluster-wide.\u003c/li\u003e\n\u003cli\u003eA service account named \u0026ldquo;default\u0026rdquo; exists in all active namespaces.\u003c/li\u003e\n\u003cli\u003eService accounts that do not belong to the kube-system namespace have no permissions.\u003c/li\u003e\n\u003cli\u003eService accounts use credentials from secrets mounted into pods. Each pod can use one service account only.\u003c/li\u003e\n\u003cli\u003eWhen you create pods, the secret in the service account is made available as a volume.\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:1,href:"/blog/",title:"Blog",description:"The foreops blog.",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()